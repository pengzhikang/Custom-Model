// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PZKSCHEMA_PZKMODEL_H_
#define FLATBUFFERS_GENERATED_PZKSCHEMA_PZKMODEL_H_

#include "flatbuffers/flatbuffers.h"

namespace PzkModel {

struct time;
struct timeBuilder;

struct TensorShape;
struct TensorShapeBuilder;

struct Weights;
struct WeightsBuilder;

struct Tensor;
struct TensorBuilder;

struct AttrMeta;
struct AttrMetaBuilder;

struct Attributes;
struct AttributesBuilder;

struct Connect;
struct ConnectBuilder;

struct Layer;
struct LayerBuilder;

struct PModel;
struct PModelBuilder;

enum DataType : int8_t {
  DataType_INT32 = 0,
  DataType_BOOL = 1,
  DataType_INT4 = 2,
  DataType_UINT4 = 3,
  DataType_INT8 = 4,
  DataType_UINT8 = 5,
  DataType_INT16 = 6,
  DataType_UINT16 = 7,
  DataType_FP16 = 8,
  DataType_FP32 = 9,
  DataType_QSYMMEINT4 = 10,
  DataType_QSYMMEINT8 = 11,
  DataType_QASYMMEUINT4 = 12,
  DataType_QASYMMEUINT8 = 13,
  DataType_UINT32 = 14,
  DataType_CHAR = 15,
  DataType_MIN = DataType_INT32,
  DataType_MAX = DataType_CHAR
};

inline const DataType (&EnumValuesDataType())[16] {
  static const DataType values[] = {
    DataType_INT32,
    DataType_BOOL,
    DataType_INT4,
    DataType_UINT4,
    DataType_INT8,
    DataType_UINT8,
    DataType_INT16,
    DataType_UINT16,
    DataType_FP16,
    DataType_FP32,
    DataType_QSYMMEINT4,
    DataType_QSYMMEINT8,
    DataType_QASYMMEUINT4,
    DataType_QASYMMEUINT8,
    DataType_UINT32,
    DataType_CHAR
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[17] = {
    "INT32",
    "BOOL",
    "INT4",
    "UINT4",
    "INT8",
    "UINT8",
    "INT16",
    "UINT16",
    "FP16",
    "FP32",
    "QSYMMEINT4",
    "QSYMMEINT8",
    "QASYMMEUINT4",
    "QASYMMEUINT8",
    "UINT32",
    "CHAR",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType_INT32, DataType_CHAR)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum TensorType : int8_t {
  TensorType_CONST = 0,
  TensorType_DYNAMIC = 1,
  TensorType_MIN = TensorType_CONST,
  TensorType_MAX = TensorType_DYNAMIC
};

inline const TensorType (&EnumValuesTensorType())[2] {
  static const TensorType values[] = {
    TensorType_CONST,
    TensorType_DYNAMIC
  };
  return values;
}

inline const char * const *EnumNamesTensorType() {
  static const char * const names[3] = {
    "CONST",
    "DYNAMIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorType(TensorType e) {
  if (flatbuffers::IsOutRange(e, TensorType_CONST, TensorType_DYNAMIC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorType()[index];
}

enum DataLayout : int8_t {
  DataLayout_NCHW = 0,
  DataLayout_NHWC = 1,
  DataLayout_ND = 2,
  DataLayout_NCD = 3,
  DataLayout_MIN = DataLayout_NCHW,
  DataLayout_MAX = DataLayout_NCD
};

inline const DataLayout (&EnumValuesDataLayout())[4] {
  static const DataLayout values[] = {
    DataLayout_NCHW,
    DataLayout_NHWC,
    DataLayout_ND,
    DataLayout_NCD
  };
  return values;
}

inline const char * const *EnumNamesDataLayout() {
  static const char * const names[5] = {
    "NCHW",
    "NHWC",
    "ND",
    "NCD",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataLayout(DataLayout e) {
  if (flatbuffers::IsOutRange(e, DataLayout_NCHW, DataLayout_NCD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataLayout()[index];
}

struct time FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef timeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_YEAR = 4,
    VT_MONTH = 6,
    VT_DAY = 8,
    VT_HOUR = 10,
    VT_MIN = 12,
    VT_SEC = 14
  };
  uint32_t year() const {
    return GetField<uint32_t>(VT_YEAR, 1998);
  }
  uint8_t month() const {
    return GetField<uint8_t>(VT_MONTH, 10);
  }
  uint8_t day() const {
    return GetField<uint8_t>(VT_DAY, 11);
  }
  uint8_t hour() const {
    return GetField<uint8_t>(VT_HOUR, 6);
  }
  uint8_t min() const {
    return GetField<uint8_t>(VT_MIN, 6);
  }
  uint8_t sec() const {
    return GetField<uint8_t>(VT_SEC, 6);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_YEAR) &&
           VerifyField<uint8_t>(verifier, VT_MONTH) &&
           VerifyField<uint8_t>(verifier, VT_DAY) &&
           VerifyField<uint8_t>(verifier, VT_HOUR) &&
           VerifyField<uint8_t>(verifier, VT_MIN) &&
           VerifyField<uint8_t>(verifier, VT_SEC) &&
           verifier.EndTable();
  }
};

struct timeBuilder {
  typedef time Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_year(uint32_t year) {
    fbb_.AddElement<uint32_t>(time::VT_YEAR, year, 1998);
  }
  void add_month(uint8_t month) {
    fbb_.AddElement<uint8_t>(time::VT_MONTH, month, 10);
  }
  void add_day(uint8_t day) {
    fbb_.AddElement<uint8_t>(time::VT_DAY, day, 11);
  }
  void add_hour(uint8_t hour) {
    fbb_.AddElement<uint8_t>(time::VT_HOUR, hour, 6);
  }
  void add_min(uint8_t min) {
    fbb_.AddElement<uint8_t>(time::VT_MIN, min, 6);
  }
  void add_sec(uint8_t sec) {
    fbb_.AddElement<uint8_t>(time::VT_SEC, sec, 6);
  }
  explicit timeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<time> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<time>(end);
    return o;
  }
};

inline flatbuffers::Offset<time> Createtime(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t year = 1998,
    uint8_t month = 10,
    uint8_t day = 11,
    uint8_t hour = 6,
    uint8_t min = 6,
    uint8_t sec = 6) {
  timeBuilder builder_(_fbb);
  builder_.add_year(year);
  builder_.add_sec(sec);
  builder_.add_min(min);
  builder_.add_hour(hour);
  builder_.add_day(day);
  builder_.add_month(month);
  return builder_.Finish();
}

struct TensorShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMSIZE = 4,
    VT_DIMS = 6
  };
  uint8_t dimsize() const {
    return GetField<uint8_t>(VT_DIMSIZE, 0);
  }
  const flatbuffers::Vector<uint32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DIMSIZE) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct TensorShapeBuilder {
  typedef TensorShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dimsize(uint8_t dimsize) {
    fbb_.AddElement<uint8_t>(TensorShape::VT_DIMSIZE, dimsize, 0);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dims) {
    fbb_.AddOffset(TensorShape::VT_DIMS, dims);
  }
  explicit TensorShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorShape> CreateTensorShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t dimsize = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> dims = 0) {
  TensorShapeBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_dimsize(dimsize);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorShape> CreateTensorShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t dimsize = 0,
    const std::vector<uint32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<uint32_t>(*dims) : 0;
  return PzkModel::CreateTensorShape(
      _fbb,
      dimsize,
      dims__);
}

struct Weights FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WeightsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELE_BYTES = 4,
    VT_ELE_NUM = 6,
    VT_BUFFER = 8
  };
  uint8_t ele_bytes() const {
    return GetField<uint8_t>(VT_ELE_BYTES, 0);
  }
  uint64_t ele_num() const {
    return GetField<uint64_t>(VT_ELE_NUM, 0);
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ELE_BYTES) &&
           VerifyField<uint64_t>(verifier, VT_ELE_NUM) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
};

struct WeightsBuilder {
  typedef Weights Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ele_bytes(uint8_t ele_bytes) {
    fbb_.AddElement<uint8_t>(Weights::VT_ELE_BYTES, ele_bytes, 0);
  }
  void add_ele_num(uint64_t ele_num) {
    fbb_.AddElement<uint64_t>(Weights::VT_ELE_NUM, ele_num, 0);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(Weights::VT_BUFFER, buffer);
  }
  explicit WeightsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Weights> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Weights>(end);
    return o;
  }
};

inline flatbuffers::Offset<Weights> CreateWeights(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t ele_bytes = 0,
    uint64_t ele_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  WeightsBuilder builder_(_fbb);
  builder_.add_ele_num(ele_num);
  builder_.add_buffer(buffer);
  builder_.add_ele_bytes(ele_bytes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Weights> CreateWeightsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t ele_bytes = 0,
    uint64_t ele_num = 0,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return PzkModel::CreateWeights(
      _fbb,
      ele_bytes,
      ele_num,
      buffer__);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TESOR_TYPE = 8,
    VT_DATA_TYPE = 10,
    VT_DATA_LAYOUT = 12,
    VT_SHAPE = 14,
    VT_WEIGHTS = 16
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  PzkModel::TensorType tesor_type() const {
    return static_cast<PzkModel::TensorType>(GetField<int8_t>(VT_TESOR_TYPE, 0));
  }
  PzkModel::DataType data_type() const {
    return static_cast<PzkModel::DataType>(GetField<int8_t>(VT_DATA_TYPE, 0));
  }
  PzkModel::DataLayout data_layout() const {
    return static_cast<PzkModel::DataLayout>(GetField<int8_t>(VT_DATA_LAYOUT, 0));
  }
  const PzkModel::TensorShape *shape() const {
    return GetPointer<const PzkModel::TensorShape *>(VT_SHAPE);
  }
  const PzkModel::Weights *weights() const {
    return GetPointer<const PzkModel::Weights *>(VT_WEIGHTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int8_t>(verifier, VT_TESOR_TYPE) &&
           VerifyField<int8_t>(verifier, VT_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_DATA_LAYOUT) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyTable(shape()) &&
           VerifyOffset(verifier, VT_WEIGHTS) &&
           verifier.VerifyTable(weights()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Tensor::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_tesor_type(PzkModel::TensorType tesor_type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TESOR_TYPE, static_cast<int8_t>(tesor_type), 0);
  }
  void add_data_type(PzkModel::DataType data_type) {
    fbb_.AddElement<int8_t>(Tensor::VT_DATA_TYPE, static_cast<int8_t>(data_type), 0);
  }
  void add_data_layout(PzkModel::DataLayout data_layout) {
    fbb_.AddElement<int8_t>(Tensor::VT_DATA_LAYOUT, static_cast<int8_t>(data_layout), 0);
  }
  void add_shape(flatbuffers::Offset<PzkModel::TensorShape> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_weights(flatbuffers::Offset<PzkModel::Weights> weights) {
    fbb_.AddOffset(Tensor::VT_WEIGHTS, weights);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    PzkModel::TensorType tesor_type = PzkModel::TensorType_CONST,
    PzkModel::DataType data_type = PzkModel::DataType_INT32,
    PzkModel::DataLayout data_layout = PzkModel::DataLayout_NCHW,
    flatbuffers::Offset<PzkModel::TensorShape> shape = 0,
    flatbuffers::Offset<PzkModel::Weights> weights = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_weights(weights);
  builder_.add_shape(shape);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_data_layout(data_layout);
  builder_.add_data_type(data_type);
  builder_.add_tesor_type(tesor_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    PzkModel::TensorType tesor_type = PzkModel::TensorType_CONST,
    PzkModel::DataType data_type = PzkModel::DataType_INT32,
    PzkModel::DataLayout data_layout = PzkModel::DataLayout_NCHW,
    flatbuffers::Offset<PzkModel::TensorShape> shape = 0,
    flatbuffers::Offset<PzkModel::Weights> weights = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return PzkModel::CreateTensor(
      _fbb,
      id,
      name__,
      tesor_type,
      data_type,
      data_layout,
      shape,
      weights);
}

struct AttrMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttrMetaBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_REQUIRE = 6,
    VT_BUFFER_DATA = 8,
    VT_BUFFER_ELE_NUM = 10,
    VT_BUFFER = 12
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool require() const {
    return GetField<uint8_t>(VT_REQUIRE, 0) != 0;
  }
  PzkModel::DataType buffer_data() const {
    return static_cast<PzkModel::DataType>(GetField<int8_t>(VT_BUFFER_DATA, 0));
  }
  uint32_t buffer_ele_num() const {
    return GetField<uint32_t>(VT_BUFFER_ELE_NUM, 0);
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRE) &&
           VerifyField<int8_t>(verifier, VT_BUFFER_DATA) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER_ELE_NUM) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.EndTable();
  }
};

struct AttrMetaBuilder {
  typedef AttrMeta Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(AttrMeta::VT_KEY, key);
  }
  void add_require(bool require) {
    fbb_.AddElement<uint8_t>(AttrMeta::VT_REQUIRE, static_cast<uint8_t>(require), 0);
  }
  void add_buffer_data(PzkModel::DataType buffer_data) {
    fbb_.AddElement<int8_t>(AttrMeta::VT_BUFFER_DATA, static_cast<int8_t>(buffer_data), 0);
  }
  void add_buffer_ele_num(uint32_t buffer_ele_num) {
    fbb_.AddElement<uint32_t>(AttrMeta::VT_BUFFER_ELE_NUM, buffer_ele_num, 0);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(AttrMeta::VT_BUFFER, buffer);
  }
  explicit AttrMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AttrMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AttrMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<AttrMeta> CreateAttrMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    bool require = false,
    PzkModel::DataType buffer_data = PzkModel::DataType_INT32,
    uint32_t buffer_ele_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  AttrMetaBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_buffer_ele_num(buffer_ele_num);
  builder_.add_key(key);
  builder_.add_buffer_data(buffer_data);
  builder_.add_require(require);
  return builder_.Finish();
}

inline flatbuffers::Offset<AttrMeta> CreateAttrMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    bool require = false,
    PzkModel::DataType buffer_data = PzkModel::DataType_INT32,
    uint32_t buffer_ele_num = 0,
    const std::vector<uint8_t> *buffer = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto buffer__ = buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0;
  return PzkModel::CreateAttrMeta(
      _fbb,
      key__,
      require,
      buffer_data,
      buffer_ele_num,
      buffer__);
}

struct Attributes FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_META_NUM = 6,
    VT_META_REQUIRE_NUM = 8,
    VT_BUFFER = 10
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  uint32_t meta_num() const {
    return GetField<uint32_t>(VT_META_NUM, 0);
  }
  uint32_t meta_require_num() const {
    return GetField<uint32_t>(VT_META_REQUIRE_NUM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PzkModel::AttrMeta>> *buffer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PzkModel::AttrMeta>> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyField<uint32_t>(verifier, VT_META_NUM) &&
           VerifyField<uint32_t>(verifier, VT_META_REQUIRE_NUM) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           verifier.VerifyVectorOfTables(buffer()) &&
           verifier.EndTable();
  }
};

struct AttributesBuilder {
  typedef Attributes Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Attributes::VT_TYPE, type);
  }
  void add_meta_num(uint32_t meta_num) {
    fbb_.AddElement<uint32_t>(Attributes::VT_META_NUM, meta_num, 0);
  }
  void add_meta_require_num(uint32_t meta_require_num) {
    fbb_.AddElement<uint32_t>(Attributes::VT_META_REQUIRE_NUM, meta_require_num, 0);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::AttrMeta>>> buffer) {
    fbb_.AddOffset(Attributes::VT_BUFFER, buffer);
  }
  explicit AttributesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attributes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attributes>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attributes> CreateAttributes(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    uint32_t meta_num = 0,
    uint32_t meta_require_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::AttrMeta>>> buffer = 0) {
  AttributesBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_meta_require_num(meta_require_num);
  builder_.add_meta_num(meta_num);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attributes> CreateAttributesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    uint32_t meta_num = 0,
    uint32_t meta_require_num = 0,
    const std::vector<flatbuffers::Offset<PzkModel::AttrMeta>> *buffer = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto buffer__ = buffer ? _fbb.CreateVector<flatbuffers::Offset<PzkModel::AttrMeta>>(*buffer) : 0;
  return PzkModel::CreateAttributes(
      _fbb,
      type__,
      meta_num,
      meta_require_num,
      buffer__);
}

struct Connect FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConnectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NECESSARY = 6,
    VT_TENSOR_ID = 8
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool necessary() const {
    return GetField<uint8_t>(VT_NECESSARY, 0) != 0;
  }
  uint32_t tensor_id() const {
    return GetField<uint32_t>(VT_TENSOR_ID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_NECESSARY) &&
           VerifyField<uint32_t>(verifier, VT_TENSOR_ID) &&
           verifier.EndTable();
  }
};

struct ConnectBuilder {
  typedef Connect Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Connect::VT_NAME, name);
  }
  void add_necessary(bool necessary) {
    fbb_.AddElement<uint8_t>(Connect::VT_NECESSARY, static_cast<uint8_t>(necessary), 0);
  }
  void add_tensor_id(uint32_t tensor_id) {
    fbb_.AddElement<uint32_t>(Connect::VT_TENSOR_ID, tensor_id, 0);
  }
  explicit ConnectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Connect> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Connect>(end);
    return o;
  }
};

inline flatbuffers::Offset<Connect> CreateConnect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    bool necessary = false,
    uint32_t tensor_id = 0) {
  ConnectBuilder builder_(_fbb);
  builder_.add_tensor_id(tensor_id);
  builder_.add_name(name);
  builder_.add_necessary(necessary);
  return builder_.Finish();
}

inline flatbuffers::Offset<Connect> CreateConnectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    bool necessary = false,
    uint32_t tensor_id = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return PzkModel::CreateConnect(
      _fbb,
      name__,
      necessary,
      tensor_id);
}

struct Layer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_TYPE = 8,
    VT_INPUT_NUM = 10,
    VT_OUTPUT_NUM = 12,
    VT_INPUT_ID = 14,
    VT_OUTPUT_ID = 16,
    VT_REQUIRE_ATTRS = 18,
    VT_ATTRS = 20
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  uint8_t input_num() const {
    return GetField<uint8_t>(VT_INPUT_NUM, 0);
  }
  uint8_t output_num() const {
    return GetField<uint8_t>(VT_OUTPUT_NUM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PzkModel::Connect>> *input_id() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PzkModel::Connect>> *>(VT_INPUT_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PzkModel::Connect>> *output_id() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PzkModel::Connect>> *>(VT_OUTPUT_ID);
  }
  bool require_attrs() const {
    return GetField<uint8_t>(VT_REQUIRE_ATTRS, 0) != 0;
  }
  const PzkModel::Attributes *attrs() const {
    return GetPointer<const PzkModel::Attributes *>(VT_ATTRS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyField<uint8_t>(verifier, VT_INPUT_NUM) &&
           VerifyField<uint8_t>(verifier, VT_OUTPUT_NUM) &&
           VerifyOffset(verifier, VT_INPUT_ID) &&
           verifier.VerifyVector(input_id()) &&
           verifier.VerifyVectorOfTables(input_id()) &&
           VerifyOffset(verifier, VT_OUTPUT_ID) &&
           verifier.VerifyVector(output_id()) &&
           verifier.VerifyVectorOfTables(output_id()) &&
           VerifyField<uint8_t>(verifier, VT_REQUIRE_ATTRS) &&
           VerifyOffset(verifier, VT_ATTRS) &&
           verifier.VerifyTable(attrs()) &&
           verifier.EndTable();
  }
};

struct LayerBuilder {
  typedef Layer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(Layer::VT_ID, id, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Layer::VT_NAME, name);
  }
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Layer::VT_TYPE, type);
  }
  void add_input_num(uint8_t input_num) {
    fbb_.AddElement<uint8_t>(Layer::VT_INPUT_NUM, input_num, 0);
  }
  void add_output_num(uint8_t output_num) {
    fbb_.AddElement<uint8_t>(Layer::VT_OUTPUT_NUM, output_num, 0);
  }
  void add_input_id(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::Connect>>> input_id) {
    fbb_.AddOffset(Layer::VT_INPUT_ID, input_id);
  }
  void add_output_id(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::Connect>>> output_id) {
    fbb_.AddOffset(Layer::VT_OUTPUT_ID, output_id);
  }
  void add_require_attrs(bool require_attrs) {
    fbb_.AddElement<uint8_t>(Layer::VT_REQUIRE_ATTRS, static_cast<uint8_t>(require_attrs), 0);
  }
  void add_attrs(flatbuffers::Offset<PzkModel::Attributes> attrs) {
    fbb_.AddOffset(Layer::VT_ATTRS, attrs);
  }
  explicit LayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Layer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Layer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Layer> CreateLayer(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    uint8_t input_num = 0,
    uint8_t output_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::Connect>>> input_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::Connect>>> output_id = 0,
    bool require_attrs = false,
    flatbuffers::Offset<PzkModel::Attributes> attrs = 0) {
  LayerBuilder builder_(_fbb);
  builder_.add_attrs(attrs);
  builder_.add_output_id(output_id);
  builder_.add_input_id(input_id);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_id(id);
  builder_.add_require_attrs(require_attrs);
  builder_.add_output_num(output_num);
  builder_.add_input_num(input_num);
  return builder_.Finish();
}

inline flatbuffers::Offset<Layer> CreateLayerDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    const char *name = nullptr,
    const char *type = nullptr,
    uint8_t input_num = 0,
    uint8_t output_num = 0,
    const std::vector<flatbuffers::Offset<PzkModel::Connect>> *input_id = nullptr,
    const std::vector<flatbuffers::Offset<PzkModel::Connect>> *output_id = nullptr,
    bool require_attrs = false,
    flatbuffers::Offset<PzkModel::Attributes> attrs = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto input_id__ = input_id ? _fbb.CreateVector<flatbuffers::Offset<PzkModel::Connect>>(*input_id) : 0;
  auto output_id__ = output_id ? _fbb.CreateVector<flatbuffers::Offset<PzkModel::Connect>>(*output_id) : 0;
  return PzkModel::CreateLayer(
      _fbb,
      id,
      name__,
      type__,
      input_num,
      output_num,
      input_id__,
      output_id__,
      require_attrs,
      attrs);
}

struct PModel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PModelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AUTHOR = 4,
    VT_CREATE_TIME = 6,
    VT_VERSION = 8,
    VT_MODEL_NAME = 10,
    VT_MODEL_RUNTIME_INPUT_NUM = 12,
    VT_MODEL_RUNTIME_OUTPUT_NUM = 14,
    VT_MODEL_RUNTIME_INPUT_ID = 16,
    VT_MODEL_RUNTIME_OUTPUT_ID = 18,
    VT_ALL_TENSOR_NUM = 20,
    VT_TENSOR_BUFFER = 22,
    VT_LAYER_NUM = 24,
    VT_LAYER_BUFFER = 26
  };
  const flatbuffers::String *author() const {
    return GetPointer<const flatbuffers::String *>(VT_AUTHOR);
  }
  const PzkModel::time *create_time() const {
    return GetPointer<const PzkModel::time *>(VT_CREATE_TIME);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *model_name() const {
    return GetPointer<const flatbuffers::String *>(VT_MODEL_NAME);
  }
  uint32_t model_runtime_input_num() const {
    return GetField<uint32_t>(VT_MODEL_RUNTIME_INPUT_NUM, 0);
  }
  uint32_t model_runtime_output_num() const {
    return GetField<uint32_t>(VT_MODEL_RUNTIME_OUTPUT_NUM, 0);
  }
  const flatbuffers::Vector<uint32_t> *model_runtime_input_id() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MODEL_RUNTIME_INPUT_ID);
  }
  const flatbuffers::Vector<uint32_t> *model_runtime_output_id() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_MODEL_RUNTIME_OUTPUT_ID);
  }
  uint32_t all_tensor_num() const {
    return GetField<uint32_t>(VT_ALL_TENSOR_NUM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PzkModel::Tensor>> *tensor_buffer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PzkModel::Tensor>> *>(VT_TENSOR_BUFFER);
  }
  uint32_t layer_num() const {
    return GetField<uint32_t>(VT_LAYER_NUM, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PzkModel::Layer>> *layer_buffer() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PzkModel::Layer>> *>(VT_LAYER_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AUTHOR) &&
           verifier.VerifyString(author()) &&
           VerifyOffset(verifier, VT_CREATE_TIME) &&
           verifier.VerifyTable(create_time()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_MODEL_NAME) &&
           verifier.VerifyString(model_name()) &&
           VerifyField<uint32_t>(verifier, VT_MODEL_RUNTIME_INPUT_NUM) &&
           VerifyField<uint32_t>(verifier, VT_MODEL_RUNTIME_OUTPUT_NUM) &&
           VerifyOffset(verifier, VT_MODEL_RUNTIME_INPUT_ID) &&
           verifier.VerifyVector(model_runtime_input_id()) &&
           VerifyOffset(verifier, VT_MODEL_RUNTIME_OUTPUT_ID) &&
           verifier.VerifyVector(model_runtime_output_id()) &&
           VerifyField<uint32_t>(verifier, VT_ALL_TENSOR_NUM) &&
           VerifyOffset(verifier, VT_TENSOR_BUFFER) &&
           verifier.VerifyVector(tensor_buffer()) &&
           verifier.VerifyVectorOfTables(tensor_buffer()) &&
           VerifyField<uint32_t>(verifier, VT_LAYER_NUM) &&
           VerifyOffset(verifier, VT_LAYER_BUFFER) &&
           verifier.VerifyVector(layer_buffer()) &&
           verifier.VerifyVectorOfTables(layer_buffer()) &&
           verifier.EndTable();
  }
};

struct PModelBuilder {
  typedef PModel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_author(flatbuffers::Offset<flatbuffers::String> author) {
    fbb_.AddOffset(PModel::VT_AUTHOR, author);
  }
  void add_create_time(flatbuffers::Offset<PzkModel::time> create_time) {
    fbb_.AddOffset(PModel::VT_CREATE_TIME, create_time);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(PModel::VT_VERSION, version);
  }
  void add_model_name(flatbuffers::Offset<flatbuffers::String> model_name) {
    fbb_.AddOffset(PModel::VT_MODEL_NAME, model_name);
  }
  void add_model_runtime_input_num(uint32_t model_runtime_input_num) {
    fbb_.AddElement<uint32_t>(PModel::VT_MODEL_RUNTIME_INPUT_NUM, model_runtime_input_num, 0);
  }
  void add_model_runtime_output_num(uint32_t model_runtime_output_num) {
    fbb_.AddElement<uint32_t>(PModel::VT_MODEL_RUNTIME_OUTPUT_NUM, model_runtime_output_num, 0);
  }
  void add_model_runtime_input_id(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> model_runtime_input_id) {
    fbb_.AddOffset(PModel::VT_MODEL_RUNTIME_INPUT_ID, model_runtime_input_id);
  }
  void add_model_runtime_output_id(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> model_runtime_output_id) {
    fbb_.AddOffset(PModel::VT_MODEL_RUNTIME_OUTPUT_ID, model_runtime_output_id);
  }
  void add_all_tensor_num(uint32_t all_tensor_num) {
    fbb_.AddElement<uint32_t>(PModel::VT_ALL_TENSOR_NUM, all_tensor_num, 0);
  }
  void add_tensor_buffer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::Tensor>>> tensor_buffer) {
    fbb_.AddOffset(PModel::VT_TENSOR_BUFFER, tensor_buffer);
  }
  void add_layer_num(uint32_t layer_num) {
    fbb_.AddElement<uint32_t>(PModel::VT_LAYER_NUM, layer_num, 0);
  }
  void add_layer_buffer(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::Layer>>> layer_buffer) {
    fbb_.AddOffset(PModel::VT_LAYER_BUFFER, layer_buffer);
  }
  explicit PModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PModel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PModel>(end);
    return o;
  }
};

inline flatbuffers::Offset<PModel> CreatePModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> author = 0,
    flatbuffers::Offset<PzkModel::time> create_time = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> model_name = 0,
    uint32_t model_runtime_input_num = 0,
    uint32_t model_runtime_output_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> model_runtime_input_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> model_runtime_output_id = 0,
    uint32_t all_tensor_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::Tensor>>> tensor_buffer = 0,
    uint32_t layer_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PzkModel::Layer>>> layer_buffer = 0) {
  PModelBuilder builder_(_fbb);
  builder_.add_layer_buffer(layer_buffer);
  builder_.add_layer_num(layer_num);
  builder_.add_tensor_buffer(tensor_buffer);
  builder_.add_all_tensor_num(all_tensor_num);
  builder_.add_model_runtime_output_id(model_runtime_output_id);
  builder_.add_model_runtime_input_id(model_runtime_input_id);
  builder_.add_model_runtime_output_num(model_runtime_output_num);
  builder_.add_model_runtime_input_num(model_runtime_input_num);
  builder_.add_model_name(model_name);
  builder_.add_version(version);
  builder_.add_create_time(create_time);
  builder_.add_author(author);
  return builder_.Finish();
}

inline flatbuffers::Offset<PModel> CreatePModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *author = nullptr,
    flatbuffers::Offset<PzkModel::time> create_time = 0,
    const char *version = nullptr,
    const char *model_name = nullptr,
    uint32_t model_runtime_input_num = 0,
    uint32_t model_runtime_output_num = 0,
    const std::vector<uint32_t> *model_runtime_input_id = nullptr,
    const std::vector<uint32_t> *model_runtime_output_id = nullptr,
    uint32_t all_tensor_num = 0,
    const std::vector<flatbuffers::Offset<PzkModel::Tensor>> *tensor_buffer = nullptr,
    uint32_t layer_num = 0,
    const std::vector<flatbuffers::Offset<PzkModel::Layer>> *layer_buffer = nullptr) {
  auto author__ = author ? _fbb.CreateString(author) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto model_name__ = model_name ? _fbb.CreateString(model_name) : 0;
  auto model_runtime_input_id__ = model_runtime_input_id ? _fbb.CreateVector<uint32_t>(*model_runtime_input_id) : 0;
  auto model_runtime_output_id__ = model_runtime_output_id ? _fbb.CreateVector<uint32_t>(*model_runtime_output_id) : 0;
  auto tensor_buffer__ = tensor_buffer ? _fbb.CreateVector<flatbuffers::Offset<PzkModel::Tensor>>(*tensor_buffer) : 0;
  auto layer_buffer__ = layer_buffer ? _fbb.CreateVector<flatbuffers::Offset<PzkModel::Layer>>(*layer_buffer) : 0;
  return PzkModel::CreatePModel(
      _fbb,
      author__,
      create_time,
      version__,
      model_name__,
      model_runtime_input_num,
      model_runtime_output_num,
      model_runtime_input_id__,
      model_runtime_output_id__,
      all_tensor_num,
      tensor_buffer__,
      layer_num,
      layer_buffer__);
}

inline const PzkModel::PModel *GetPModel(const void *buf) {
  return flatbuffers::GetRoot<PzkModel::PModel>(buf);
}

inline const PzkModel::PModel *GetSizePrefixedPModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<PzkModel::PModel>(buf);
}

inline const char *PModelIdentifier() {
  return "PZKM";
}

inline bool PModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, PModelIdentifier());
}

inline bool VerifyPModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<PzkModel::PModel>(PModelIdentifier());
}

inline bool VerifySizePrefixedPModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<PzkModel::PModel>(PModelIdentifier());
}

inline const char *PModelExtension() {
  return "pmodelmeta";
}

inline void FinishPModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<PzkModel::PModel> root) {
  fbb.Finish(root, PModelIdentifier());
}

inline void FinishSizePrefixedPModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<PzkModel::PModel> root) {
  fbb.FinishSizePrefixed(root, PModelIdentifier());
}

}  // namespace PzkModel

#endif  // FLATBUFFERS_GENERATED_PZKSCHEMA_PZKMODEL_H_
